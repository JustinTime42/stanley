"""HTML test reporter for browser automation results.

This module provides the HTMLReporter class for generating comprehensive HTML
reports from browser test results, including pass/fail status, timing information,
screenshots, visual diffs, and error details.
"""

import logging
from typing import List, Dict, Any
from pathlib import Path
from datetime import datetime
import base64

from src.models.browser_models import (
    VisualTestResult,
    AccessibilityIssue,
    PerformanceMetrics,
)

logger = logging.getLogger(__name__)


class HTMLReporter:
    """Generate HTML test reports with results, screenshots, and visual diffs.

    This class creates comprehensive HTML reports from browser test results,
    including visual test comparisons, accessibility issues, performance metrics,
    and user journey results.

    PATTERN: Use inline CSS and base64-encoded images for self-contained reports.
    """

    def __init__(self, output_dir: str = "test-reports"):
        """Initialize the HTML reporter.

        Args:
            output_dir: Directory to save generated reports
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(
            f"HTML reporter initialized with output directory: {self.output_dir}"
        )

    def generate_report(
        self,
        test_results: Dict[str, Any],
        report_name: str = "test-report",
        include_screenshots: bool = True,
    ) -> str:
        """Generate a comprehensive HTML test report.

        Args:
            test_results: Dictionary containing test results
            report_name: Name for the report file (without extension)
            include_screenshots: Whether to embed screenshots in report

        Returns:
            Path to the generated HTML report

        Example:
            reporter = HTMLReporter()
            results = {
                "summary": {"total": 10, "passed": 8, "failed": 2},
                "tests": [...],
                "visual_tests": [...],
                "accessibility_issues": [...],
            }
            report_path = reporter.generate_report(results, "e2e-tests")
        """
        logger.info(f"Generating HTML report: {report_name}")

        try:
            # Generate report sections
            html_content = self._build_html_structure(
                test_results, report_name, include_screenshots
            )

            # Save report to file
            report_path = self.output_dir / f"{report_name}.html"
            with open(report_path, "w", encoding="utf-8") as f:
                f.write(html_content)

            logger.info(f"HTML report generated successfully: {report_path}")
            return str(report_path)

        except Exception as e:
            logger.error(f"Failed to generate HTML report: {e}")
            raise

    def _build_html_structure(
        self,
        test_results: Dict[str, Any],
        report_name: str,
        include_screenshots: bool,
    ) -> str:
        """Build the complete HTML structure for the report.

        Args:
            test_results: Test results dictionary
            report_name: Report name
            include_screenshots: Whether to include screenshots

        Returns:
            Complete HTML content as string
        """
        summary = test_results.get("summary", {})
        tests = test_results.get("tests", [])
        visual_tests = test_results.get("visual_tests", [])
        accessibility_issues = test_results.get("accessibility_issues", [])
        performance_metrics = test_results.get("performance_metrics", [])
        errors = test_results.get("errors", [])

        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{report_name} - Test Report</title>
    {self._get_styles()}
</head>
<body>
    <div class="container">
        <header>
            <h1>{report_name}</h1>
            <p class="timestamp">Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
        </header>

        {self._build_summary_section(summary)}
        {self._build_tests_section(tests, include_screenshots)}
        {self._build_visual_tests_section(visual_tests, include_screenshots)}
        {self._build_accessibility_section(accessibility_issues)}
        {self._build_performance_section(performance_metrics)}
        {self._build_errors_section(errors)}

        <footer>
            <p>Browser Test Report - Generated by Agent Swarm</p>
        </footer>
    </div>

    {self._get_scripts()}
</body>
</html>"""

        return html

    def _get_styles(self) -> str:
        """Get inline CSS styles for the report.

        Returns:
            HTML style tag with CSS
        """
        return """<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 10px;
        }

        h2 {
            color: #34495e;
            font-size: 1.5em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        h3 {
            color: #2c3e50;
            font-size: 1.2em;
            margin: 15px 0 10px;
        }

        .timestamp {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .section {
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .summary-card {
            padding: 20px;
            border-radius: 6px;
            text-align: center;
        }

        .summary-card.total {
            background: #ecf0f1;
            border-left: 4px solid #95a5a6;
        }

        .summary-card.passed {
            background: #d5f4e6;
            border-left: 4px solid #27ae60;
        }

        .summary-card.failed {
            background: #fadbd8;
            border-left: 4px solid #e74c3c;
        }

        .summary-card.skipped {
            background: #fef5e7;
            border-left: 4px solid #f39c12;
        }

        .summary-card .value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-card .label {
            font-size: 0.9em;
            text-transform: uppercase;
            color: #7f8c8d;
        }

        .test-item {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .test-item.passed {
            border-left: 4px solid #27ae60;
            background: #f8fff9;
        }

        .test-item.failed {
            border-left: 4px solid #e74c3c;
            background: #fff8f8;
        }

        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .test-name {
            font-weight: bold;
            font-size: 1.1em;
        }

        .test-status {
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .test-status.passed {
            background: #27ae60;
            color: white;
        }

        .test-status.failed {
            background: #e74c3c;
            color: white;
        }

        .test-meta {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .error-message {
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #c33;
        }

        .screenshot-container {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .screenshot-box {
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .screenshot-box img {
            width: 100%;
            height: auto;
            display: block;
        }

        .screenshot-label {
            background: #f5f5f5;
            padding: 8px 12px;
            font-size: 0.85em;
            font-weight: bold;
            text-align: center;
        }

        .visual-diff {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .diff-stats {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .diff-stats p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        .issue-item {
            border-left: 4px solid #e74c3c;
            background: #fff;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .issue-item.critical {
            border-left-color: #c0392b;
        }

        .issue-item.serious {
            border-left-color: #e74c3c;
        }

        .issue-item.moderate {
            border-left-color: #f39c12;
        }

        .issue-item.minor {
            border-left-color: #95a5a6;
        }

        .impact-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
            text-transform: uppercase;
            margin-right: 8px;
        }

        .impact-badge.critical {
            background: #c0392b;
            color: white;
        }

        .impact-badge.serious {
            background: #e74c3c;
            color: white;
        }

        .impact-badge.moderate {
            background: #f39c12;
            color: white;
        }

        .impact-badge.minor {
            background: #95a5a6;
            color: white;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .metric-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }

        .metric-card.good {
            border-left-color: #27ae60;
        }

        .metric-card.needs-improvement {
            border-left-color: #f39c12;
        }

        .metric-card.poor {
            border-left-color: #e74c3c;
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 5px 0;
        }

        .metric-label {
            font-size: 0.9em;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .collapsible {
            cursor: pointer;
            user-select: none;
        }

        .collapsible:hover {
            opacity: 0.8;
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.active {
            max-height: 2000px;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
    </style>"""

    def _build_summary_section(self, summary: Dict[str, Any]) -> str:
        """Build the summary section of the report.

        Args:
            summary: Summary statistics

        Returns:
            HTML for summary section
        """
        total = summary.get("total", 0)
        passed = summary.get("passed", 0)
        failed = summary.get("failed", 0)
        skipped = summary.get("skipped", 0)
        duration = summary.get("duration_ms", 0)

        pass_rate = (passed / total * 100) if total > 0 else 0

        return f"""
        <div class="section">
            <h2>Test Summary</h2>
            <div class="summary-grid">
                <div class="summary-card total">
                    <div class="value">{total}</div>
                    <div class="label">Total Tests</div>
                </div>
                <div class="summary-card passed">
                    <div class="value">{passed}</div>
                    <div class="label">Passed</div>
                </div>
                <div class="summary-card failed">
                    <div class="value">{failed}</div>
                    <div class="label">Failed</div>
                </div>
                <div class="summary-card skipped">
                    <div class="value">{skipped}</div>
                    <div class="label">Skipped</div>
                </div>
            </div>
            <div style="margin-top: 20px; text-align: center;">
                <p><strong>Pass Rate:</strong> {pass_rate:.1f}%</p>
                <p><strong>Duration:</strong> {duration / 1000:.2f}s</p>
            </div>
        </div>"""

    def _build_tests_section(
        self, tests: List[Dict[str, Any]], include_screenshots: bool
    ) -> str:
        """Build the tests section of the report.

        Args:
            tests: List of test results
            include_screenshots: Whether to include screenshots

        Returns:
            HTML for tests section
        """
        if not tests:
            return ""

        tests_html = '<div class="section"><h2>Test Results</h2>'

        for test in tests:
            name = test.get("name", "Unnamed Test")
            status = test.get("status", "unknown")
            duration_ms = test.get("duration_ms", 0)
            error = test.get("error")
            screenshot = test.get("screenshot")

            tests_html += f"""
            <div class="test-item {status}">
                <div class="test-header">
                    <div class="test-name">{name}</div>
                    <div class="test-status {status}">{status}</div>
                </div>
                <div class="test-meta">
                    Duration: {duration_ms / 1000:.2f}s
                </div>"""

            if error:
                tests_html += f"""
                <div class="error-message">{self._escape_html(error)}</div>"""

            if include_screenshots and screenshot:
                tests_html += f"""
                <div class="screenshot-container">
                    <div class="screenshot-box">
                        <div class="screenshot-label">Screenshot</div>
                        {self._get_image_html(screenshot)}
                    </div>
                </div>"""

            tests_html += "</div>"

        tests_html += "</div>"
        return tests_html

    def _build_visual_tests_section(
        self, visual_tests: List[VisualTestResult], include_screenshots: bool
    ) -> str:
        """Build the visual tests section.

        Args:
            visual_tests: List of visual test results
            include_screenshots: Whether to include images

        Returns:
            HTML for visual tests section
        """
        if not visual_tests:
            return ""

        section_html = '<div class="section"><h2>Visual Regression Tests</h2>'

        for vtest in visual_tests:
            status = "passed" if vtest.is_match else "failed"
            section_html += f"""
            <div class="test-item {status}">
                <div class="test-header">
                    <div class="test-name">{vtest.test_id}</div>
                    <div class="test-status {status}">{status}</div>
                </div>
                <div class="diff-stats">
                    <p><strong>Match:</strong> {vtest.match_percentage:.2f}%</p>
                    <p><strong>Pixel Difference:</strong> {vtest.pixel_difference:,}</p>
                    <p><strong>Threshold:</strong> {vtest.threshold * 100:.2f}%</p>
                </div>"""

            if include_screenshots:
                section_html += f"""
                <div class="visual-diff">
                    <div class="screenshot-box">
                        <div class="screenshot-label">Baseline</div>
                        {self._get_image_html(vtest.baseline_path)}
                    </div>
                    <div class="screenshot-box">
                        <div class="screenshot-label">Actual</div>
                        {self._get_image_html(vtest.actual_path)}
                    </div>"""

                if vtest.diff_path:
                    section_html += f"""
                    <div class="screenshot-box">
                        <div class="screenshot-label">Diff</div>
                        {self._get_image_html(vtest.diff_path)}
                    </div>"""

                section_html += "</div>"

            section_html += "</div>"

        section_html += "</div>"
        return section_html

    def _build_accessibility_section(self, issues: List[AccessibilityIssue]) -> str:
        """Build the accessibility issues section.

        Args:
            issues: List of accessibility issues

        Returns:
            HTML for accessibility section
        """
        if not issues:
            return ""

        section_html = (
            f'<div class="section"><h2>Accessibility Issues ({len(issues)})</h2>'
        )

        for issue in issues:
            section_html += f"""
            <div class="issue-item {issue.impact}">
                <div>
                    <span class="impact-badge {issue.impact}">{issue.impact}</span>
                    <strong>{issue.rule_id}</strong> - {issue.description}
                </div>
                <p style="margin-top: 10px; color: #555;">
                    <strong>Element:</strong> <code>{self._escape_html(issue.selector)}</code>
                </p>
                <p style="margin-top: 5px; color: #555;">
                    <strong>Fix:</strong> {issue.fix_suggestion or issue.help_text}
                </p>
            </div>"""

        section_html += "</div>"
        return section_html

    def _build_performance_section(self, metrics_list: List[PerformanceMetrics]) -> str:
        """Build the performance metrics section.

        Args:
            metrics_list: List of performance metrics

        Returns:
            HTML for performance section
        """
        if not metrics_list:
            return ""

        section_html = '<div class="section"><h2>Performance Metrics</h2>'

        for metrics in metrics_list:
            cwv_status = "good" if metrics.passes_cwv else "poor"

            section_html += f"""
            <h3>{metrics.url}</h3>
            <div class="metric-grid">
                <div class="metric-card {self._get_metric_status(metrics.lcp, 2500, 4000)}">
                    <div class="metric-label">LCP (Largest Contentful Paint)</div>
                    <div class="metric-value">{metrics.lcp:.0f}ms</div>
                </div>
                <div class="metric-card {self._get_metric_status(metrics.fid, 100, 300)}">
                    <div class="metric-label">FID (First Input Delay)</div>
                    <div class="metric-value">{metrics.fid:.0f}ms</div>
                </div>
                <div class="metric-card {self._get_metric_status(metrics.cls, 0.1, 0.25, lower_better=True)}">
                    <div class="metric-label">CLS (Cumulative Layout Shift)</div>
                    <div class="metric-value">{metrics.cls:.3f}</div>
                </div>
                <div class="metric-card {self._get_metric_status(metrics.ttfb, 800, 1800)}">
                    <div class="metric-label">TTFB (Time to First Byte)</div>
                    <div class="metric-value">{metrics.ttfb:.0f}ms</div>
                </div>
                <div class="metric-card {self._get_metric_status(metrics.fcp, 1800, 3000)}">
                    <div class="metric-label">FCP (First Contentful Paint)</div>
                    <div class="metric-value">{metrics.fcp:.0f}ms</div>
                </div>
                <div class="metric-card {self._get_metric_status(metrics.tti, 3800, 7300)}">
                    <div class="metric-label">TTI (Time to Interactive)</div>
                    <div class="metric-value">{metrics.tti:.0f}ms</div>
                </div>
            </div>
            <p style="margin-top: 15px; text-align: center;">
                <strong>Core Web Vitals Status:</strong>
                <span style="color: {"#27ae60" if metrics.passes_cwv else "#e74c3c"}; font-weight: bold;">
                    {cwv_status.upper()}
                </span>
            </p>"""

        section_html += "</div>"
        return section_html

    def _build_errors_section(self, errors: List[Dict[str, Any]]) -> str:
        """Build the errors section.

        Args:
            errors: List of errors

        Returns:
            HTML for errors section
        """
        if not errors:
            return ""

        section_html = f'<div class="section"><h2>Errors ({len(errors)})</h2>'

        for error in errors:
            error_type = error.get("type", "Error")
            message = error.get("message", "Unknown error")
            stack = error.get("stack")

            section_html += f"""
            <div class="test-item failed">
                <div class="test-header">
                    <div class="test-name">{error_type}</div>
                </div>
                <div class="error-message">
                    {self._escape_html(message)}"""

            if stack:
                section_html += f"""
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer;">Stack Trace</summary>
                        <pre style="margin-top: 10px; font-size: 0.85em;">{self._escape_html(stack)}</pre>
                    </details>"""

            section_html += """
                </div>
            </div>"""

        section_html += "</div>"
        return section_html

    def _get_scripts(self) -> str:
        """Get inline JavaScript for interactive features.

        Returns:
            HTML script tag with JavaScript
        """
        return """<script>
        // Add collapsible functionality
        document.addEventListener('DOMContentLoaded', function() {
            const collapsibles = document.querySelectorAll('.collapsible');
            collapsibles.forEach(function(collapsible) {
                collapsible.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    content.classList.toggle('active');
                });
            });
        });
    </script>"""

    def _get_image_html(self, image_path: str) -> str:
        """Generate HTML for displaying an image.

        Args:
            image_path: Path to image file

        Returns:
            HTML img tag (base64-encoded or file path)
        """
        try:
            path = Path(image_path)
            if path.exists():
                with open(path, "rb") as f:
                    image_data = base64.b64encode(f.read()).decode("utf-8")
                    ext = path.suffix.lower()
                    mime_type = "image/png" if ext == ".png" else "image/jpeg"
                    return f'<img src="data:{mime_type};base64,{image_data}" alt="Screenshot">'
            else:
                return f'<p style="color: #999; padding: 20px;">Image not found: {image_path}</p>'
        except Exception as e:
            logger.warning(f"Failed to load image {image_path}: {e}")
            return '<p style="color: #999; padding: 20px;">Failed to load image</p>'

    def _get_metric_status(
        self,
        value: float,
        good_threshold: float,
        poor_threshold: float,
        lower_better: bool = False,
    ) -> str:
        """Determine metric status based on thresholds.

        Args:
            value: Metric value
            good_threshold: Threshold for good performance
            poor_threshold: Threshold for poor performance
            lower_better: Whether lower values are better

        Returns:
            Status class: 'good', 'needs-improvement', or 'poor'
        """
        if lower_better:
            if value <= good_threshold:
                return "good"
            elif value <= poor_threshold:
                return "needs-improvement"
            else:
                return "poor"
        else:
            if value <= good_threshold:
                return "good"
            elif value <= poor_threshold:
                return "needs-improvement"
            else:
                return "poor"

    def _escape_html(self, text: str) -> str:
        """Escape HTML special characters.

        Args:
            text: Text to escape

        Returns:
            HTML-escaped text
        """
        if not text:
            return ""
        return (
            str(text)
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
            .replace("'", "&#x27;")
        )

    def generate_summary_report(
        self,
        test_runs: List[Dict[str, Any]],
        report_name: str = "test-summary",
    ) -> str:
        """Generate a summary report across multiple test runs.

        Args:
            test_runs: List of test run results
            report_name: Name for the summary report

        Returns:
            Path to the generated summary report

        Example:
            reporter = HTMLReporter()
            runs = [run1_results, run2_results, run3_results]
            summary_path = reporter.generate_summary_report(runs, "weekly-summary")
        """
        logger.info(f"Generating summary report: {report_name}")

        try:
            # Aggregate statistics
            total_runs = len(test_runs)
            total_tests = sum(
                run.get("summary", {}).get("total", 0) for run in test_runs
            )
            total_passed = sum(
                run.get("summary", {}).get("passed", 0) for run in test_runs
            )
            total_failed = sum(
                run.get("summary", {}).get("failed", 0) for run in test_runs
            )

            summary_data = {
                "summary": {
                    "total_runs": total_runs,
                    "total": total_tests,
                    "passed": total_passed,
                    "failed": total_failed,
                    "skipped": 0,
                },
                "runs": test_runs,
            }

            # Generate report
            return self.generate_report(
                summary_data, report_name, include_screenshots=False
            )

        except Exception as e:
            logger.error(f"Failed to generate summary report: {e}")
            raise
